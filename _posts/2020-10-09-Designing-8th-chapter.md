---
title: "Eighth Chapter"
excerpt: "분산시스템의 골칫거리"
categories:
  - Designing
tags:
  - Study
  - Computer science
last_modified_at: 2020-10-09T08:06:00+09:00
---

# 08장

## 클라우드 컴퓨팅과 슈퍼컴퓨팅

슈퍼컴퓨터에서 실행되는 작업은 계산 상태를 저장소에 체크포인트로 저장. 따라서 노드 하나에 장애가 발생하면
흔한 해결책은 전체 클러스터의 부하를 중단. 장애 발생한 노트 복구 후 마지막 체크포인트부터 다시 계산 시작

분산 시스템은 부분 장애 가능성을 받아들이고 내결함성 매커니즘을 넣어야한다. 신뢰성 없는 구성요소들로 신뢰성 있는 시스템을 구축해야함

## 신뢰성 없는 네트워크

인터넷과 데이터 센터 내부 네트워크 대부분은 비동기 패킷 네트워크. 이런 종류의 네트워크에서 노드는 다른
노드로 메시지를 보낼 수 있지만 도착을 보장해 주지 않는다. 유일한 방법은 수신측에서 응답 메시지를 보내주는 것이지만
응답 메시지도 손실 지연 될 수 있다. 이러한 문제를 다루는 흔한 방법 중 하나는 **타임아웃**이다.

네트워크 결함의 오류 처리가 정의되지 않으면 나쁜 일이 생길 수 있음. 예를 들어 클러스터가 교착상태에 빠져 네트워크 복구 후에도
요청 처리를 못하는 경우도 있음.

반드시 모든 네트워크 결함을 견뎌내도록 처리할 필요는 없음. 평상 시 상당히 잘 동작한다면, 문제 시 사용자들에게 오류 메시지를 보여주는 것도
일종의 방법. 그러나 소프트웨어가 어떻게 결함에 반응하는지 알고 복구할 수 있도록 보장해야한다.

### 타임아웃과 기약 없는 지연

타임아웃이 길면 죽었다고 선언되는 기간이 길어짐. 즉 사용자들이 더 오래 기다림. 대신 타임아웃이 짧으면 결함은 빨리 발견하지만 노드가
일시적으로 느려졌을 뿐인데도 죽었다고 잘 못 선언할 위험이 생김.

또한 노드가 죽었다고 선언이 되면, 그 노드의 일은 다른 노드로 전달되어야 해서 다른 노드들에게 추가적인 부담을 줌. 시스템이 이미 높은
부하를 받는 중이면 이러한 경우 다른 노드로 부하를 전달하면서 연쇄 장애를 유발하는 경우도 생김(극단적인 경우 모든 노드들이 서로를 죽었다고 선언)

즉 이러한 환경에서는 실험적으로 타임아웃을 선택해야한다. 지연의 변동성을 긴 시간에 걸쳐 네트워크 분포 측정을 통해 알아내야한다. 그 후
장애 감지와 이른 타임아웃의 위험성 사이에서 적절하게 선택해야함.

더 좋은 방법중 하나는 고정된 타임아웃을 선택하되 시스템이 지속적으로 응답시간과 그들의 변동성을 측정하고, 관찰된 시간 분포에 따라 타임아웃을
자동적으로 조절하게 하는것이다. 이를 사용하는 예로 아카와 카산드라가 있다.

## 신뢰성 없는 시계

시계와 시간은 매우 중요. 분산 시스템은 통신이 즉각적이지 않으므로 시간은 다루기 까다롭다. 메시지가 다른 장비로 전달되는데도 시간이 걸리기 때문이다.

### 단조 시계와 일 기준 시계

현대 컴퓨터는 최소 두가지 종류 시계를 가짐. 일 기준 시계와 단조시계이다.

### 일 기준 시계

어떤 달력에 따라 현재 날짜와 시간을 반환. 벽 시계라고도 한다. 예를 들어 리눅스의 `clock_gettime(CLOCK_REALTIME)`과 자바의
`System.currentTimeMillis()`는 에포크 이래로 흐른 초를 반환한다. 윤초는 세지 않으며 에포크는 그레고리력에 따르면 UTC(협정세계시)
1970년 1월 1일 자정을 가리킨다.

일 기준 시계는 보통 NTP로 동기화된다. 한 장비의 타임스태프는 이상적으로 다른 장비의 타임스탬프와 동일한 의미를 지닌다는 뜻. 그러나 특이점들이 존재.
예를 들어 로컬 시계가 NTP 서버보다 너무 앞서면 강제로 리셋되어 과거시점으로 거꾸로 뛴것처럼 보일 수 있음. 이런 뜀은 일 기준 시간이 경과 시간을
측정하는데 적합하지 않게 만듬.

### 단조 시계

단조 시계는 타임아웃이나 서비스 응답 시간 같은 지속 시간을 재는 데 적합. 예를 들어 리눅스의 `clock_gettime(CLOCK_MONOTONIC)`과 자바의
`System.nanoTime()`이 있음. 단조 시계란 이름은 항상 앞으로 흐른다는 사실에서 나옴(일 기준 시계는 뒤로 뛸 수도 있음).

한 시점에서 단조 시계 값을 확인하고 다른 시점에서 확인하여 시간 측정 가능. 하지만 다른 두대의 컴퓨터에서 나온 단조 시계 값을 비교하는 것은 의미가 없음.

여러개의 cpu소켓이 있는 서버는 cpu마다 독립된 타이머를 가질 수 있음. 이 타이머는 다른 cpu와 반드시 동기화 된다고 볼 수 없음. OS에서 차이를 보정해서
스레드가 여러 cpu에 걸쳐 스케쥴링 되더라도 시계가 단조적으로 보이게 하려함. 하지만 보장은 곧이 곧대로 받아들이지 않는게 좋다.

분산 시스템에서 경과 시간을 재는데 단조 시계를 쓰는 것은 일반적으로 괜찮다. 다른 노드 시계 사이에 동기화가 돼야한다는 가정이 없기 때문이다.

### 시게 동기화와 정확도

단조 시계는 동기화가 필요 없지만 일 기준 시계는 NTP서버나 다른 외부 시간 출처에 맞춰 설정되야 유용함. 하지만 하드웨어 시계나 ntp는 변덕스러울 수도 있다.

- 컴퓨터의 수정 시계는 정확치 않음. 더 빨라지거나 느려지는 **드리프트** 현상이 생김. 구글은 자신들의 서버에 200ppm(백만분의 1)의 시계 드리프트가 있다고 가정함.

- 뜻하지 않게 노드와 NTP서버와의 통신이 막히면, 잘못된 설정이 얼마동안 알려지지 않을 수도 있음.

- 가상 장비에서 하드웨어 시계는 가상화 되서 정확한 시간 엄수 필요한 애플리케이션에 어려움이 생김. cpu코어가 가상장비에서 공유될때 각 vm은 다른 vm실행되는 동안 수십 밀리초 멈춤
  애플리케이션 관점에서 이 중단은 시계가 갑자기 앞으로 튀는 현상으로 보임

시계 정확도가 매우 중요해 상당한 자원을 투자할 생각이 있으면 정확도를 매우 높이는 것도 가능함. 예를 들어 유럽 금융기관은 모두 그들의 시계를 UTC와 100마이크로초 이내로
동기화 하기를 요구. 이런 정확도는 gps 수신기, 정밀 시간 프로토콜 과 세심한 모니터링을 사용하여 달성할 수 있음. 대신 상당한 기술 및 노력이 필요함

### 동기화된 시계에 의존하기

네트워크와 마찬가지로 시계에 결함에 대비할 필요가 있음. 한가지 문제는 시계는 잘못되도 눈치채기가 쉽지 않다는 것. 시계에 결함이 있어도 시스템은 잘 동작하는것 처럼 보임. 소프트웨어의
어떤 부분이 동기화된 시계에 의존한다면 극적인 고장보다는 조용하고 미묘한 손실이 발생할 가능성이 높음.

따라서 동기화된 시계가 필요한 소프트웨어를 개발한다면 필수적으로 장비 사이의 시계차이를 조심스럽게 모니터링 해야한다. 다른 노드와 시계가 너무 차이나는 노드는 죽은것으로 선언되고 클러스터에서
제거해야함.

## 다수결

분산 시스템은 한 노드에만 의존할 수 없다. 노드에 언제든 장애가 나서 시스팀에 멈추고 복구할 수 없게 될 수 있다.
대신 여러 분산 알고리즘 정족수, 즉 노드에 투표에 의존한다.
특정한 하나의 노드에 의존을 줄이기 위해 결정을 하려면 여러 노드로부터 최소 갯수의 투표를 받아야 함.

정족수 이상을 이룬 노드들이 다른 노드를 죽었다고 선언하면 그 노드가 여전히 살아 있다고 느낄지라도 죽은것으로 간주해야함.

보통 노드의 과반수를 정족수로 삼는게 흔함. 과반수를 사용하면 개별 노드들에 장애가 나더라도 시스템은 계속 동작가능함.
