---
title:  "First Chapter"
excerpt: "신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션"
categories:
  - Designing
tags:
  - Study
  - Computer science
last_modified_at: 2020-06-29T08:06:00+09:00
---

# 01장

## 데이터 시스템에 대한 생각

왜 모든 것(데이터베이스, 큐, 시스템)을 **데이터 시스템**으로 묶어야 하는가?

1. 데이터 저장과 처리를 위한 여러 새로운 도구들은 전통적인 분류에 들어맞지 않는다.
2. 점점 많은 애플리케이션이 단일로써 데이터 처리, 저장을 만족시킬 수 없고 광범위한 요구사항을 가지고.

이 책에선 3가지 관심사에 중점을 둔다.

- 신뢰성
- 확장성
- 유지보수

## 신뢰성

하드웨어나 소프트웨어 결함 or 인적오류 같은 문제에도 시스템은 지속적으로 올바르게 동작해야 한다.

**결함**: 잘못될 수 있는 일. 사양에서 벗어난 시스템의 한 구성 요소 정도로 정의

**장애**: 시스템 전체가 멈춘 경우

=> 결함으로 인해 장애가 생기지 않게끔 설계하여야 함

### 하드웨어 결함

하드디스크의 평균 장애 시간은 10 ~ 50년

주로 하드디스크의 중복으로 인해 장애율 낮춤.

점차 소프트웨어 내결함성 기술을 사용하거나 하드웨어 중복성을 추가해 장비 손실을 견딜 수 있는 시스템으로 옮겨감

### 소프트웨어 오류

하드웨어 결함은 보통 무작위적이며 독립적. 즉 한 장비의 장애로 인해 다른 장비에 장애가 발생하지 않는다. ( 온도와 같은 약 상관관계는 존재)

다른 부류로는 시스템 내 체계적 오류 존재. 예상하기 더 어렵고 노드간 관계 때문에 오류를 더 많이 유발하는 경우 존재

ex)

1. 잘못된 특정 입력으로 모든 애플리케이션 서버 인스턴스가 죽는 버그
2. 공유 자원 과도하게 사용하는 일부 프로세스
3. 시스템 속도 저하로 인한 무반응 혹은 잘못된 응답

위와 같은 버그는 특정 상황에 의해 발생하기 전까지 오랫동안 나타나지 않음.

이러한 소프트웨어의 체계적 오류 문제들은 신속한 해결책 없음

시스템의 상호작용에 대한 깊은 생각, 빈틈없는 테스트, 프로세스 격리, 죽은 프로세스 재시작 허용 등 작은 일들이 해결에 도움을 줄 수 있음

### 인적 오류

대부분의 오류가 인적오류

최고의 시스템은 다양한 접근 방식 결합

1. 오류의 가능성을 최소화 하는 방향으로 설계해라.
2. 많이 실수하는 부분에서 장애가 발생할 수 있는 부분을 분리.
3. 단위 테스트부터 전체 시스틈 통합 테스트 모든 수준에서 철저히 테스트.
4. 인적 오류를 빠르고 쉽게 복구할 수 있게 해야함. 설정 변경 내역을 빠르게 롤백하고 코드를 서서히 롤 아웃하게 만들어라.(버그 일부 사용자에게만 영향이 미치게끔)
5. 성능 지표와 오류율 같은 상세하고 명확한 모니터링 대책 마련.

## 확장성

성능 저하를 유발하는 흔한 이유 중 하나는 부하 증가

### 부하 기술하기

시스템의 현재 부하를 간결하게 기술해야한다. 그래야 부하 성장에 대한 질문(부하가 2배로 되면 어떻게 될까)를 논의할 수 있다. 부하는 **부하 매개변수(load parameter)**이라 부르는 몇 개의 숫자로 나타낼 수 있다. (데이터 읽기 쓰기 비율, 웹 서버의 초당 요청 수, 대화방 동시 활성 사용자 수, 캐시 적중률 등..)

ex) 트위터

주요 두 가지 동작 -> 트윗 작성(팔로워에게 새로운 메시지 게시, 평균 초당 4.6k, 피크 시 12k 이상), 홈 타임라인(팔로우한 사람의 트윗 확인, 초당 300k 요청)

방식 2가지

1. 새로운 트윗을 트윗 전역 컬렉션에 삽입. 사용자가 자신의 타임라인 요청시 팔로우하는 모든 사람을 찾고, 이 사람들의 모든 트윗을 찾아 시간순으로 정렬
2. 개별 사용자 마다 홈 타임라인 캐시 유지. 사용자가 트윅 작성시 해당 사용자를 팔로우하는 사람을 찾아 팔로워의 홈 타임라인 캐시에 트윗을 삽입.

트위터의 첫 번째 버전은 1번 방식.

=> 홈 타임라인 부하를 유지하기 힘듬 -> 2번 방식으로 교체

게시되는 트윗 속도가 홈 타인라인 읽기속도보다 작기 때문에 2번이 더 잘 동작함. 쓰기 시점에 더 많이 일하고 읽기 시점에 적게 일함.

하지만 2의 단점은 트윗 작성이 많은 부가 작업을 필요로 함. 평균적으로는 더 낫지만 사용자의 팔로워 수에 따라 달라짐. 일부 사용자는 수 많은 팔로워를 가지고 있어 단일 트윗 작성 한번이 홈 타임라인 캐쉬에 몇 천만건 이상의 요청이 될 수도 있음.

트위터의 경우 사용자당 팔로워의 분포가 부하를 결정하기 때문에 확장성 논의시 **핵심 부하 매개변수**가 된다.

트위터의 최종 전개는 혼합형. 대부분의 경우 2를 사용, 유명인은 제외. 사용자가 팔로우한 유명인의 트윗은 별도로 가져와 1번 방식처럼 읽는 시점에 홈 타임라인에 합친다.

### 성능 기술하기

시스팀 부하를 기술하면 부하가 일어날 시 어떤 일이 일어나는지 조사가능. 다음 2가지 방법으로 살펴볼 수 있다.

1. 부하 매개변수를 증가시키고 시스템 자원(cpu, 메모리, 네트워크 대역폭 등)은 변경하지 않고 유지하면 시스템 성능은 어떤 영향을 받을까
2. 부하 매개변수를 증가시켰을 때 성능이 변하지 않고 유지되길 원한다면 얼마나 많은 시스템 자원을 늘려야 할까

위의 두 질문 모드 성능 수치가 필요

하둡과 같은 일괄 처리 시스템은 보통 **처리량**(초당 처리할 수 있는 레코드 수로 작업을 수행할 때 걸리는 전체 시간)에 관심을 둠

온라인 시스템에서 더 중요한 사항은 **응답 시간**, 클라이언트가 요청 보내고 응답을 받는데 걸리는 시간

클라이언트가 여러번 응답을 보내도 매번 응답시간은 다르다. 따라서 응답시간은 단일 숫자가 아니라 측정 가능한 값의 분포로 생각해야함. 일반적으로 평균 보다 백분위를 사용하는 편이 더 좋음. 

응답 시간 목록을 가지고 정렬하면 중간 지점이 중앙값이 됨. 사용자가 보통 얼마나 오랫동안 기다려야 하는지 알고 싶다면 중앙값이 좋은 지표. 

특이 값이 얼마나 좋지 않은지 알아보려면 상위 백분위를 살펴보는것도 좋다. 보통 95, 99, 99.9분위가 일반적. 상위 백분위 응답 시간은 사용자 경험에 직접적인 영향을 알려주기 때문에 매우 중요. 아마존은 응답시간이 100밀리초 증가하면 판매량 1프로 감소, 1초가 느려지면 고객 만족도 16프로가 줄어드는 현상을 관찰

반면에 99.99(10000건중 가장 느린 1건)의 최적화 작업에는 비용이 너무 많이 소모되어 아마존이 추구하는 목표에 충분한 이익을 가져다주지 못한다고 여겨짐. 특히 최상위 백분위는 임의의 사건에 영향을 많이 받기 때문에 응답 시간 줄이기가 매우 어려워 이점이 더욱 줄어듬.

**큐 대기 지연** 은 높은 백분위에서 응답 시간의 상당한 부분을 차지. 소수의 느린 요청으로 인해 후속 요청 처리가 지체됨. 이런 문제 때문에 클라이언트 쪽 응답 시간 측정이 중요함

시스템의 확장성을 테스트하려고 인위적인 부하를 생성하는 경우, 부하 생성 클라이언트는 지속적인 요청을 보내야함. 이전 요청 기다리면서 테스트하면 대기 시간을 실제보다 더 짧게 만들어 평가를 왜곡시킴

### 부하 대응 접근 방식

보통 **용량 확장(수직 확장: 좀 더 강력한 장비)** 과 **규모 확장(수평 확장: 다수의 낮은 사양 장비에 부하 분산)** 으로 구분하곤 한다. 

일부 시스템은 탄력적. 즉 부하 증가를 감지하면 컴퓨팅 자원을 자동으로 추가 가능. 하지만 그렇지 않은 시스템은 수동으로 확장( 사람이 용량 분석, 시스템에 더 많은 장비 추가)해야 함. 탄력적인 시스템은 부하를 예측하기 힘들만큼 높은 경우 매우 유용, 수동으로 확장하는 시스템이 더 간단하고 예기치 못한 일이 더 적음.

이전엔 확장비용이나 데이터베이스를 분산으로 만들어야 하는 요구가 있을때까지 단일 노드에 유지하는 것이 통념 => 분산 시스템을 위한 도구와 추상화가 적어지며 바뀌고 있다. 

특정 애플리 케이션에 적합한 확장성을 갖춘 아키텍처는 주요 동작이 무엇이고 잘 하지 않는 동작이 무엇인지에 대한 가정을 기반으로 구축. 이 가정은 즉 매개변수가 됨. 대신 잘못된 가정일 시에 역효과를 낳음. 따라서 초기 단계에는 미래를 가정한 확장보다는 빠른 반복으로 제품 기능 개선작업이 중요

## 유지보수성

소프트웨어의 대부분의 비용은 초기 개발이 아닌 유지보수. 

대부분  레거시 시스템 유지보수 작업을 좋아하지 않음.  모든 레거시 시스템은 각자 나름대로의 불편함이 존재하고, 이러한 레거시 소프트웨어를 만들지 않게 끔 해야한다. 그러기 위해 주의를 기울여야하는 시스템 설계 원칙은 다음 세가지이다.

* 운용성: 운영팀이 시스템을 원할하게 운영할 수 있도록 쉽게 만들어라.
* 단순성: 시스템에서 복잡도를 최대한 제거해 새로운 엔지니어가 시스템을 이해하기 쉽게 만들어라(ui단순성과는 다름)
* 발전성: 엔지니어가 쉽게 시스템을 변경할 수 있게 해라.

### 운용성

시스템을 지속적으로 원할하게 작동하려면 운영팀이 필수

좋은 운용성이란 동일하게 반복되는 태스크를 쉽게 수행하게 만들어 운영팀이 활동에 집중한다는 의미. 

데이터 시스템은 반복 작업을 쉽게 하기 위해 아래 항목을 포함해 다양한 일을 할 수 있다.

* 좋은 모니터링으로 시스템 내부에 대한 가시성 제공
* 표준 도구를 이용해 자동화와 통합을 위한 지원 제공
* 유지 보수를 위해 장비를 내리더라도 시스템 전체에 영향을 주지 않게 해야함
* 좋은 문서와 이해하기 쉬운 운영 모델
* 적절하게 자기 회복이 가능하고 필요에 따라 관리자가 수동으로 제어할 수 있게 함

### 단순성

복잡도는 같은 시스템에서 작업하는 사람의 진행을 느리게하고 유지보수 비용을 증가시킴. 

시스템을 단순하게 만드는 일이 반드시 기능을 줄인다는 의미는 아님. 우발적 복잡도를 줄인다는 의미.

우발적 복잡도를 제거하기 위한 최상의 도구는 추상화이다. 좋은 추상화는 깔끔하고 직관적이며 많은 세부 구현을 숨길 수 있음. 또한 다양한 애플리케이션에서 사용 가능. 재구현보다 효율적이며 좋은 소프트웨어로 이어짐.

### 발전성

조직 프로세스 측면에서 애자일 작업 패턴은 변화에 적응하기 쉽다. 애자일 기법에 대한 설명은 매우 작고 로컬 규모에 초점을 맞추고 있음

